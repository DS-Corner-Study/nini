최적화란 웹 서비스의 성능을 개선하는 기술 / 렌더링 성능 높임
리액트 앱에서 연산 최적화는 대부분 Memorization 기법 이용
말뜻 그대로 메모하는 방법..특정 입력에 대한 결과를 계산해 메모리 어딘가에 저장했다가, 동일한 요청이 들어오면 저장한 결괏값을 제공해 빠르게 응답하는 기술
useMemo는 메모이제이션 기법을 이용해 연산의 결괏값을 기억했다가 필요할 때 사용함으로써 불필요한 함수 호출을 막아주는 리액트 훅
함수 useMemo를 호출하고 2개의 인수로 콜백 함수와 의존성 배열(deps)를 전달 호출된 useMemo는 의존성 배열에 담긴 값이 바뀌면 콜백 함수를 다시 실행하고 결괏값을 반환한다
const value = useMemo(callback, deps);
의존성 배열 count의 값이 변할 때만 count*count를 계산해 value에 저장하려면
const value = useMemo(() => {
    return count * count;
}, [count]);
React.memo를 이용하면 메모이제이션 기법으로 컴포넌트가 불필요하게 리렌더되는 상황을 방지할 수 있다
고차 컴포넌트는 인수로 전달된 컴포넌트를 새로운 컴포넌트로 반환하는 함수 다만, 전달된 컴포넌트를 그대로 반환하는 것이 아니라 어떤 기능을 추가해 반환(강화된 컴포넌트)
고차 컴포넌트 이용하면 횡단 관심사 문제를 효율적으로 해결할 수 있어 실무에서 많이 활용
컴포넌트의 핵심 기능을 세로로 배치한다고 했을 때, 여러 컴포넌트에서 공통으로 사용하는 기능은 가로로 배치
-> 공통 기능들이 핵심 컴포넌트들을 마치 '횡단'하는 모습
useCallback은 컴포넌트가 리렌더될 때 내부에 작성된 함수를 다시 생성하지 않도록 메모이제이션 하는 리액트 훅
useCallback은 useMemo처럼 2개의 인수 제공 첫 번째 인수로는 메모이제이션하려는 콜백 함수 전달하고, 두 번째 인수로는 의존성 배열을 전달--결과로 useCallback은 메모이제이션된 함수 반환한다
const memoizedFunc = useCallback(func, deps)
만약 첫 번째 인수로 전달한 콜백 함수를 어떤 경우에도 다시 생성되지 않게 하려면 의존성 배열을 빈 배열로 전달
최적화할 때 유의할 점
1. 최적화는 항상 마지막에
2. 모든 것을 최적화할 필요는 없다
3. 컴포넌트 구조를 잘 설계했는지 다시 한번 돌아봐라
